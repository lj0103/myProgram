内存泄漏和垃圾回收机制
===
1.什么是内存泄漏
---
> 程序的运行需要内存。只要程序提出请求，操作系统会在运行时为程序分配内存。对于持续运行的服务进程，必须及时释放不使用的内存，否则占用内存就会越来越来多，轻则影响性能，严重甚至会导致进程崩溃。
> 
> **不再用到的内存没有及时得到释放，就叫做内存泄漏**

2.常见的内存泄漏
---
- 意外的全局变量
  
    1）在Javascript中未声明的变量会在全局变量上创建该变量的引用(即全局对象上的属性，不是变量，因为它能通过delete删除)。如果在浏览器中，全局对象就是window对象。

    2）如果未声明的变量缓存大量的数据，只有在关闭浏览器或者刷新页面的时候这些数据才会被释放，这就会造成意外的内存泄漏

    3）解决方式：可以在使用的时候用'use srtict'严格模式，避免这种情况，只有需要全局变量的时候再去定义，定义方法为：window.a=""
- console.log
   
    1）console.log是我们开发中常用一种调试手段，就是想web开发控制台发一条消息，打印输出内容，但是很多程序员会忘记把自己的输出内容在产品发布上线的时候删除掉，就会导致生产环境发生内存泄漏。
    2）解决方法：开始时注意console.log的使用，避免console.log出现在生产环境。
- 闭包

   1）由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。这是了解闭包的人懂的一个闭包的过多使用的弊端。

   2）解决方式：不要过度使用闭包。避免闭包滥用。
- DOM泄漏

  1）因为JavaScript/ECMAScript引擎独立于渲染引擎，而DOM是位于渲染引擎，相互访问需要消耗一定的资源。DOM访问次数过多会造成页面性能变差，为了减少对DOM的访问，有时会将DOM引用缓存到一个局部变量中，如果执行了一些删除或者更新操作，但是忘记释放掉代码中的DOM引用，可能会造成DOM的内存泄漏。
  
  2）解决方式：及时释放DOM引用。
- timers（定时器）

  1）如果在不需要setInterval()时，没有通过clearInterval()方法移除，setInterval()没有被及时清除就会被不停的调用，直到clearInterval()或者窗口关闭。如果链式setTimeout()调用模式没有给出终止逻辑，也会一直运行下去。都会造成内存泄漏。

  2）解决方式：及时清除定时器。
- EventListener
  
  1）做移动开发时，需要对不同设备尺寸做适配。如在开发组件时，有时需要考虑处理横竖屏适配问题。一般做法，在横竖屏发生变化时，需要将组件销毁后再重新生成。而在组件中会对其进行相关事件绑定，如果在销毁组件时，没有将组件的事件解绑，在横竖屏发生变化时，就会不断地对组件进行事件绑定。这样会导致一些异常，甚至可能会导致页面崩掉。在开发中，开发者很少关注事件解绑，因为浏览器已经为我们处理得很好了。不过在使用第三方库时，需要特别注意，因为一般第三方库都实现了自己的事件绑定，如果在使用过程中，在需要销毁事件绑定时，没有调用所解绑方法，就可能造成事件绑定数量的不断增加
  
  2）解决方式：关注事件解绑。
  
3.垃圾回收机制
---
>在C语言中，需要手动释放内存，由程序员负责内存管理，这个给程序员造成了很大负担。在很多语言中都提供了自动内存管理，帮助程序员减轻了负担，这就是垃圾回收机制。

  1）最常使用的方法叫做"引用计数"（reference counting）：语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。

  2）引用计数法 上面的引用计数法的弊端已经很明显了，那么，现在所要说的标记清除法就不存在这样子的问题。因为它采用的判断标准是看这个对象是否可抵达，它主要分为两个阶段，标记阶段和清除阶段

  标记阶段：垃圾收集器会从根对象（Window对象）出发，扫描所有可以触及的对象，这就是所谓的可抵达

  清除阶段：在扫描的同时，根对象无法触及（不可抵达）的对象,就是被认为不被需要的对象，就会被当成垃圾清除

4.内存泄漏的识别方法
---
源自阮一峰大师：
http://www.ruanyifeng.com/blog/2017/04/memory-leak.html

5.WeakMap
---

前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。

最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。

ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个"Weak"，表示这是弱引用。
